# 自己动手构造编译系统
## 编译系统概述
- 编译器: 输入为源文件(\*.c),输出为汇编文件(\*.s)  
  词法分析->语法分析->符号表管理->语义分析->编译优化->代码生成  
  现代编译器结构如图:  
  [![JEHfht.md.png](https://s1.ax1x.com/2020/04/17/JEHfht.md.png)](https://imgchr.com/i/JEHfht)  
  [![JEbV9x.md.png](https://s1.ax1x.com/2020/04/17/JEbV9x.md.png)](https://imgchr.com/i/JEbV9x)  
      
- 汇编器: 输入为源文件(\*.s),输出为可重定位文件(\*.o)   
  词法分析->语法分析->表信息生成(ELF文件中的段表,符号表,重定位表)->指令生成->目标文件生成  
  汇编器结构如图:  
  [![JEbaDg.png](https://s1.ax1x.com/2020/04/17/JEbaDg.png)](https://imgchr.com/i/JEbaDg)  

- 链接器:输入为可重定位文件(\*.o),输出为可执行文件ELF  
  地址空间分配->符号解析->重定位  
  链接器结构如图:  
  [![JEqiM8.md.png](https://s1.ax1x.com/2020/04/17/JEqiM8.md.png)](https://imgchr.com/i/JEqiM8)  

- ELF文件格式  
  linux下ELF主要有四种:可执行文件,可重定位目标文件,共享目标文件(动态链接器相关),核心转储文件(coreDump,错误现场相关)  
  ELF格式如图:  
  [![JELCk9.png](https://s1.ax1x.com/2020/04/17/JELCk9.png)](https://imgchr.com/i/JELCk9)  
## 编译器构造(高级语言->汇编语言)
### 词法分析  
此法分析器结构如图:  
[![JZ5NDJ.png](https://s1.ax1x.com/2020/04/17/JZ5NDJ.png)](https://imgchr.com/i/JZ5NDJ)  
- 扫描器读取源文件,按序返回文件内的字符,直到文件结束
- 词法记号通常分为:标识符、关键字、常量、分界符
- 有限自动机分为NFA和DFA,DFA识别的语言称为正则语言
- 解析器根据DFA/NFA完成词法记号的解析,实现方式有基于表驱动(词法分析器生成工具一般用这种方式)和硬编码(程序直接解析,效率较高)两种  
  EAC中还有介绍一种Direct-Coded, 因该是介于自动化生成与手工编码之间
### 语法分析
语法分析器结构如图:  
[![JKjWy4.png](https://s1.ax1x.com/2020/04/19/JKjWy4.png)](https://imgchr.com/i/JKjWy4)  
#### 文法定义
- 0型文法: 限制最少,能力相当于图灵机
- 1型文法: 上下文有关文法, 对应于线性有界自动机
- 2型文法: 上下文无关文法,对应于下推自动机,程序语言最常用的文法
- 3型文法: 正则文法,对应于有限状态自动机  

上下文无关文法常见的文法分析算法包括自顶向下的LL(1),自底向上的LR分析  
LL1文法的要求比LR分析严格,不允许文法中出现左递归和左公因子,虽然LR分析对文法要求较宽松,但是LR分析器手工构造较为复杂  
GCC编译器使用LL(2)文法分析器
### 符号表管理
主要包括作用域管理, 变量管理和函数管理
### 语义分析
- 语义分析实现并未统一标准,本项目主要是解决语法分析不能或者很难处理的上下文相关信息
- 简单实现如下三种语义检查:
  - 声明与定义: 变量/函数重定义,变量/函数未声明, 函数声明与定义不匹配,函数定义不允许使用extern  
  - 表达式: 函数调用时实参与形参的匹配,表达式不能作为左值,函数的void返回值不能参与表达式运算,赋值类型不匹配,数组索引运算错误
  - 语句语义: break/switch/continue不在循环, return语句与函数返回值不匹配
### 编译优化
本项目的简易优化器结构如图:  
[![JM9cf1.png](https://s1.ax1x.com/2020/04/19/JM9cf1.png)](https://imgchr.com/i/JM9cf1)  
#### 数据流分析
IR优化一般是在是在数据流分析的基础上进行的,且满足通用的数据流分析框架  
基于数据流分析的IR优化一般分为三步:  
[![JMPsR1.png](https://s1.ax1x.com/2020/04/19/JMPsR1.png)](https://imgchr.com/i/JMPsR1)  
1. IR CFG构造: 一般由BB(basic block)和控制边构成
2. 对CFG进行数据流分析,获得需要的数据流信息.  
数据流分析框架的四个基本要素:  
  - 数据流方向(backward/forward)  
  - 值集(边界(Entry/Exit)集合,初值集合)  
  - 交会函数(meet/join)  
  - 传递函数(transfer function)
3. 根据数据流信息指导IR优化
#### 中间代码优化
种类很多,项目实现了:  
- constant propagation: 分析结束后,所有的指令对象内都保存了执行指令前后所有可见变量的常量性质  
- copy propagation: 分析结束后,每条指令的入口集合内都保存了有效的复写表达式集合
- dead code elimination: 分析结束后,指令的出口集合保存了所有将来要使用的变量集合,  
如果对变量的定值指令的出口集合中不包含该变量,则将该指令标记为死代码
#### 寄存器分配(业界编译器一般是后端部分)
常用算法有:
- 图着色算法: 基于变量活跃性分析构造的冲突图来进行寄存器分配的算法
- 线性扫描算法: 速度比图着色快,但是精度不如图着色,未深入了解🤭
#### 窥孔优化/Peephole Optimization(后端的指令选择过程中会涉及)
窥孔优化对目标代码线性扫描,使用一个固定大小的滑动窗口监视扫描位置的代码序列,并将该序列与已设定的代码模板进行匹配,执行指令的替换、消除、合并等优化动作
### 代码生成
- IR生成: 为了屏蔽不同ISA细节,通常先生成IR,在IR上做优化
- 目标代码生成: 优化过的IR->ISA
- ELF相关: 生成汇编一般包括数据段和代码段,其中数据段一般又可细分为: 
  - .data: 保存所有已初始化的全局变量
  - .bss: 保存所有未初始化的全局变量
  - .rodata: 保存所有常量字符串的内容
## 汇编器构造(汇编语言>二进制语言)
- 词法分析、语法分析、符号表管理和编译器相似，且往往汇编语言由编译器生成，正确性由编译器保证，因此不需要error handle.  
因为汇编允许前向跳转，有可能跳转的目标符号还未记录在符号表中  
因此一般汇编器需要对汇编程序进行两遍扫描，第一遍负责扫描所有符号信息，第二遍则处理前向跳转中的符号信息，未确定符号则确定是外部符号
- 表信息生成：可重定位目标文件最关键的三个段是:段表、符号表和重定位表
- 指令生成：根据指令编码生成对应二进制指令
- 目标文件生成：主要分为ELF文件结构组装和ELF文件结构输出两大部分
  - ELF文件结构组装：根据扫描得到ELF文件信息，完善ELF文件结构的数据
  - ELF文件结构输出：输出文件头、代码段、数据段...等ELF文件内容(还要负责偏移的对其补充)
## 链接器构造(static)(二进制->二进制)
- 信息收集：逐个扫描输入的目标文件,提取信息,建立必要的数据结构缓存linker所需信息
- 地址空间分配：为可重定位目标文件中虚拟地址默认为0的段指定加载地址
- 符号解析：根据已经计算的段加载地址计算符号的虚拟地址，同时还要分析目标文件之间符号的引用情况，计算目标文件内引用的外部符号的地址
- 重定位：符号解析后通过重定位操作修正代码段或数据段内引用的符号地址
- 程序入口点与运行时库：提供调用main函数的运行时库，该库负责调用main函数以及从main退出后和OS交互的工作
- 可执行文件生成：与汇编器相似，分为ELF文件结构组装和ELF文件结构输出两个阶段