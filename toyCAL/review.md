# 自己动手构造编译系统
## 编译系统概述
- 编译器: 输入为源文件(\*.c),输出为汇编文件(\*.s)  
  词法分析->语法分析->符号表管理->语义分析->编译优化->代码生成  
  现代编译器结构如图:  
  [![JEHfht.md.png](https://s1.ax1x.com/2020/04/17/JEHfht.md.png)](https://imgchr.com/i/JEHfht)  
  [![JEbV9x.md.png](https://s1.ax1x.com/2020/04/17/JEbV9x.md.png)](https://imgchr.com/i/JEbV9x)  
      
- 汇编器: 输入为源文件(\*.s),输出为可重定位文件(\*.o)   
  词法分析->语法分析->表信息生成(ELF文件中的段表,符号表,重定位表)->指令生成->目标文件生成  
  汇编器结构如图:  
  [![JEbaDg.png](https://s1.ax1x.com/2020/04/17/JEbaDg.png)](https://imgchr.com/i/JEbaDg)  

- 链接器:输入为可重定位文件(\*.o),输出为可执行文件ELF  
  地址空间分配->符号解析->重定位  
  链接器结构如图:  
  [![JEqiM8.md.png](https://s1.ax1x.com/2020/04/17/JEqiM8.md.png)](https://imgchr.com/i/JEqiM8)  

- ELF文件格式  
  linux下ELF主要有四种:可执行文件,可重定位目标文件,共享目标文件(动态链接器相关),核心转储文件(coreDump,错误现场相关)  
  ELF格式如图:  
  [![JELCk9.png](https://s1.ax1x.com/2020/04/17/JELCk9.png)](https://imgchr.com/i/JELCk9)  
## 编译器构造
### 词法分析  
此法分析器结构如图:  
[![JZ5NDJ.png](https://s1.ax1x.com/2020/04/17/JZ5NDJ.png)](https://imgchr.com/i/JZ5NDJ)  
- 扫描器读取源文件,按序返回文件内的字符,直到文件结束
- 词法记号通常分为:标识符、关键字、常量、分界符
- 有限自动机分为NFA和DFA,DFA识别的语言称为正则语言
- 解析器根据DFA/NFA完成词法记号的解析,实现方式有基于表驱动(词法分析器生成工具一般用这种方式)和硬编码(程序直接解析,效率较高)两种  
  EAC中还有介绍一种Direct-Coded, 因该是介于自动化生成与手工编码之间
### 语法分析
语法分析器结构如图:  
[![JKjWy4.png](https://s1.ax1x.com/2020/04/19/JKjWy4.png)](https://imgchr.com/i/JKjWy4)  
#### 文法定义
- 0型文法: 限制最少,能力相当于图灵机
- 1型文法: 上下文有关文法, 对应于线性有界自动机
- 2型文法: 上下文无关文法,对应于下推自动机,程序语言最常用的文法
- 3型文法: 正则文法,对应于有限状态自动机  

上下文无关文法常见的文法分析算法包括自顶向下的LL(1),自底向上的LR分析  
LL1文法的要求比LR分析严格,不允许文法中出现左递归和左公因子,虽然LR分析对文法要求较宽松,但是LR分析器手工构造较为复杂  
GCC编译器使用LL(2)文法分析器
### 符号表管理
主要包括作用域管理, 变量管理和函数管理
### 语义分析
- 语义分析实现并未统一标准,本项目主要是解决语法分析不能或者很难处理的上下文相关信息
- 简单实现如下三种语义检查:
  - 声明与定义: 变量/函数重定义,变量/函数未声明, 函数声明与定义不匹配,函数定义不允许使用extern  
  - 表达式: 函数调用时实参与形参的匹配,表达式不能作为左值,函数的void返回值不能参与表达式运算,赋值类型不匹配,数组索引运算错误
  - 语句语义: break/switch/continue不在循环, return语句与函数返回值不匹配
### 编译优化
本项目的简易优化器结构如图:  
[![JM9cf1.png](https://s1.ax1x.com/2020/04/19/JM9cf1.png)](https://imgchr.com/i/JM9cf1)  
#### 数据流分析
IR优化一般是在是在数据流分析的基础上进行的,且满足通用的数据流分析框架  
基于数据流分析的IR优化一般分为三步:  
[![JMPsR1.png](https://s1.ax1x.com/2020/04/19/JMPsR1.png)](https://imgchr.com/i/JMPsR1)  
1. IR CFG构造: 一般由BB(basic block)和控制边构成
2. 对CFG进行数据流分析,获得需要的数据流信息.  
数据流分析框架的四个基本要素:  
  - 数据流方向(backward/forward)  
  - 值集(边界(Entry/Exit)集合,初值集合)  
  - 交会函数(meet/join)  
  - 传递函数(transfer function)
3. 根据数据流信息指导IR优化
#### 中间代码优化
种类很多,项目实现了:  
- constant propagation: 分析结束后,所有的指令对象内都保存了执行指令前后所有可见变量的常量性质  
- copy propagation: 分析结束后,每条指令的入口集合内都保存了有效的复写表达式集合
- dead code elimination: 分析结束后,指令的出口集合保存了所有将来要使用的变量集合,  
如果对变量的定值指令的出口集合中不包含该变量,则将该指令标记为死代码
#### 寄存器分配(业界编译器一般是后端部分)
#### 窥孔优化(后端的指令选择过程中会涉及)
### 代码生成
- IR生成: 为了屏蔽不同ISA细节,通常先生成IR,在IR上做优化
- 目标代码生成: 优化过的IR->ISA
- ELF相关: 生成汇编一般包括数据段和代码段,其中数据段一般又可细分为: 
  - .data: 保存所有已初始化的全局变量
  - .bss: 保存所有未初始化的全局变量
  - .rodata: 保存所有常量字符串的内容
## 汇编器构造
### 词法分析
### 语法分析
### 符号表管理
### 表信息生成
### 指令生成
### 目标文件生成
## 链接器构造(static)
### 信息收集
### 地址空间分配
### 符号解析
### 重定位
### 程序入口点与运行时库
### 可执行文件生成